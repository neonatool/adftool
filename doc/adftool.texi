\input texinfo
@include version.texi
@settitle Reading and writing data with adftool @value{VERSION}
@syncodeindex pg cp
@setfilename adftool.info

@copying
Huh… I’ll have to think about copying conditions…
@end copying

@dircategory Texinfo documentation system
@direntry
* adftool: (adftool)Invoking adftool.
@end direntry

@titlepage
@title Reading and writing data with adftool
@subtitle for version @value{VERSION}, @value{UPDATED}
@author Vivien Kraus (@email{vivien.kraus@@univ-reims.fr})
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@node Top
@top Adftool

This is the user manual for adftool (version @value{VERSION},
@value{UPDATED}).

@menu
* The ADF file format::
* Invoking adftool::
* The libadftool API::
* Index::
@end menu

@node The ADF file format
@chapter The ADF file format

@cindex linked data
With the help of the World-wide Web, any dataset can be published in a
form that can be understood both by humans and by machines. The most
successful approach to that is @dfn{Linked Data}: each data point is
assigned a URI, and it is possible to follow the links from one piece
of data to another piece of data to build distributed knowledge
graphs, in a very similar manner that the web of documents lets user
click links to discover new pages. In that way, it is possible to
augment any dataset with new information, without touching at how
other systems use the same data.

@cindex RDF
@cindex subject
@cindex predicate
@cindex object
@cindex graph
@cindex triple
@cindex quad
@cindex statement
To do this, the Resource Description Framework (@dfn{RDF}) has been
introduced. It maps data to graphs. More specifically, a piece of data
consists of a @dfn{subject}, a @dfn{predicate}, and an
@dfn{object}. Each of them is a piece of data too. A later revision
added the notion of @dfn{graphs}, to partition the data into different
views. These four elements constitute a @dfn{quad}, or a @dfn{triple}
if the graph is the default graph. This is also called a
@dfn{statement}. So, good systems to store and query sets of quads or
triples need to be used to process linked data.

@cindex allotrope data format
@cindex ADF
@cindex hierarchical data format
@cindex HDF
This project is a more complete specification of the Allotrope Data
Format Quad Store, defined at
@url{https://docs.allotrope.org/ADF%20Quad%20Store%20API.html}. It is
designed to work within a Hierarchical Data Format file.

@menu
* Overview of the quad store::
* Building indices::
* The dictionary::
* Storage of statements::
* Indexing statements::
@end menu

@node Overview of the quad store
@section Overview of the quad store

The quad store is a data structure to hold triples or quads, along
with indices for efficient querying of the data set. The queries that
can be solved by the file format are of the form:

@example
?@var{subject} ?@var{predicate} ?@var{object} ?@var{graph} .
@end example

where @var{subject}, @var{predicate}, @var{object} and @var{graph} can
be defined as RDF nodes, or empty.

Internally, statements, or quads, are stored as a set of tuples. Each
element of the tuple may be a named node (IRI reference), a blank node
with an identifier, a typed literal, or a literal with an localization
mark.

@cindex named node
@cindex IRI reference
A named node is a resource that one can try to dereference to access
more data about the thing it represents. It is usually written between
angle brackets, as an IRI or IRI reference:

@example
<https://example.org/resource?query-arguments#identifier>
@end example

Subjects, predicates, objects or graphs can be named nodes.

@cindex blank node
A blank node is an unnamed resource that can be used to link other
resources together, scoped to the resource.

@example
<#me> <#knows> _:@var{someone} .
_:@var{someone} <#knows> <#someone-else> .
@end example

In this example, there is no more information about the person
identified as @var{someone}, than it is a link in my social
network. Any other resource using @code{_:@var{someone}} will be
interpreted as talking to someone else.

Only subjects and objects may be blank nodes.

@cindex literal
@cindex typed literal
@cindex type
@cindex langstring
@cindex langtag
The literal is a piece of data that does not have further metadata. It
is composed of a literal @dfn{value}, and an optional @dfn{type} or an
optional @dfn{langtag}. The type is identified by an IRI reference,
and it is usually expected to be one of the XML Schema Definition
vocabulary. If no type is present, the
@samp{<http://www.w3.org/2001/XMLSchema#string>} type is assumed. If the
string is to be presented to a human, then it may have a localization
tag, or langtag, indicating its locale.

@example
<#me> <#likes> "ananas"^^<http://www.w3.org/2001/XMLSchema#string> .
<#me> <#likes> "pineapples"@@en .
@end example

Literals can only be used as objects.

@cindex term ordering
@cindex order
We define an order on terms, as the byte lexicographic order of their
UTF-8 encoding (which is the same as the unicode code point
order). Each prefix of a term comes strictly before the term
itself. The textual representation of a term is constructed as:

@table @emph
@item for a named node
the IRI reference, without further percent-encoding, surrounded by
angle brackets (no whitespace);
@item for a blank node
the string @code{_:} (underscore, colon) followed by the unescaped
identifier of the blank node;
@item for a typed literal
a double quote, the escaped string (only the double quote character
and backslash character require escaping), another double quote, the
type marker @code{^^}, and the encoding of the type URI. If the type
is missing, @samp{<http://www.w3.org/2001/XMLSchema#string>} is
used. No extra whitespace is added;
@item for a langstring
a double quote, the escaped string, a double quote, the @code{@@}
character, and the langtag.
@end table

@cindex pattern
It is also possible to order statements, by using the lexicographic
order of the terms. We extend the notion of statement or quad to that
of @dfn{pattern}, by making the subject, predicate, object and graph
optional, and by stating that a missing object compares equal to any
term.

For query answering, the specification maintains 6 indices of the
data: @samp{GSPO}, @samp{GPOS}, @samp{GOSP}, @samp{SPOG}, @samp{POSG}
and @samp{OSPG}. In these acronyms, @samp{G} means graph, @samp{S}
means subject, @samp{P} means predicate and @samp{O} means object. Any
of the 16 search patterns that can be formed by specifying some of the
elements of the quad can be searched in one of these 6 indices. For
instance, if @var{predicate} and @var{graph} are set, the query can be
answered by using the @samp{GPOS} index.

The algorithm is, given a search @var{pattern}, to find in an index
all quads that compare equal to @var{pattern}, using the search order
that corresponds to the index.

@node Building indices
@section Building indices

@cindex B+
@cindex leaf
@cindex non-leaf
The file format uses B+ nodes to build indices. These are search trees
that have been designed to work well on computers that have a
cache. Each node in the tree is either a @dfn{leaf}, or a
@dfn{non-leaf}. Only leaves contain the actual data. In this file
format, a B+ tree is always associated with a table that stores
things. The associated table can do a lookup operation efficiently:
given a row index, it can return in constant time the content of the
row. Also, the associated table can grow by adding items at the
end. This is implemented by the HDFS file format.

@cindex associated table
So, for all uses of B+ trees here, both keys and values are actually
indices in the @dfn{associated table}. In fact, in all uses of B+
trees, the key is equal to the value. This is represented as a 32-bit
unsigned integer value.

The B+ trees are themselves stored in a 2D dataset in the file, each
row corresponding to a tree node. The first row (number 0) is always
the root of the tree.

@cindex nextID
Each dataset in this file format can grow, but no row is allowed to be
missing if a row is used after it. Thus, all elements are
contiguous. However, to get (amortized) logarithmic append time, the
datasets are allowed to be larger than what is strictly required. In
any case, each dataset has an attribute named @dfn{nextID} attached to
it, that indicates the number of rows actually used.

@cindex order
@cindex node order
The @dfn{node order} of a B+ tree is defined as one plus the number of
keys that each node can hold. Each row of the storage dataset for a B+
tree of a given @var{order} has @math{2 * @var{order} + 1}
columns. They are of type unsigned 32-bit integer.

The first @code{@var{order} - 1} columns are dedicated to the
keys. The index of the first -1 value (modulo @math{2 ^ 32}) is the
number of keys present in the node. The keys are indices in the
associated dataset.

For a leaf node, the next @code{@var{order} - 1} columns are dedicated
to the associated values (so, the same as the key). An additional
column is the node index (in the B+ dataset) of the next leaf, with 0
meaning no next leaf. Since 0 is the root anyway, it can only be a
leaf if it is the only node in the tree. If it is the only node, there
are no next leaves.

For a non-leaf node, the next @code{@var{order}} columns are dedicated
to the children of the node, as indices in the B+ dataset. The first
child contains only keys that are lesser than or equal to the first
key. The last child contains all keys that are strictly greater than
the last key in the node.

The next column is the ID of the parent, as index in the B+
dataset. The root has a value -1 (modulo @math{2 ^ 32}) for its
parent.

Finally, the last column contains node flags. If the most significant
bit of the value is set (@math{2 ^ 31}), then the node is a
leaf. Otherwise, it is not a leaf.

In any situations, if there is at least 2 nodes in the tree, each node
has at least @math{@var{order} / 2} children or values, which ensures
that the tree is dense enough to guarantee fast traversal. To traverse
a B+ node given a @var{key}, one must find the first key index @var{k}
such that @math{@var{lookup} (@var{k}) >= @var{key}}, where
@var{lookup} is the function that looks up a key index in the
associated storage.

@node The dictionary
@section The dictionary

@cindex dictionary
The dictionary is a specific index, for sequences of bytes. It is
composed of a B+ tree, stored under @code{/dictionary/keys},
associated to a storage under @code{/dictionary/strings}. An
additional 1-dimensional storage of bytes under
@code{/dictionary/bytes} stores long strings. For a dictionary, the
associated storage is thus the strings dataset.

The strings dataset has 13 columns, each as unsigned 8-bit
numbers. Considering a big-endian virtual machine, these columns can
also be interpreted as 3 columns, the first spanning 8 bytes, the
second 4 bytes, and the last 1 byte. In any case, the last column can
always be interpreted as a 8-bit number.

If the value for the last column is 0, then the string is a long
string. In that case, it must be interpreted as a 3-column
dataset. The first big-endian 8 bytes indicate an @var{offset}, and
the next 4 bytes indicate a @var{length}. If @var{length} is 0, then
it represents the empty string. The empty string is used to mean the
default graph. Otherwise, the string is composed of the @var{length}
bytes that start at @var{offset} in the @emph{/dictionary/bytes}
dataset.

If the value for the last column is not 0, then it is at most 12. The
dataset row must be interpreted as 12 bytes, and a string
@var{length}. The string is thus the first @var{length} bytes of the
row.

Contrary to the storage of statements, the dictionary has only 1
index.

@node Storage of statements
@section Storage of statements

@node Indexing statements
@section Indexing statements

@node Invoking adftool
@chapter Invoking adftool

@pindex adftool
@cindex invoking @command{adftool}

@node The libadftool API
@chapter The libadftool API

@cindex API (libadftool)
@cindex libadftool

@node Index
@unnumbered Index
@printindex cp

@bye
