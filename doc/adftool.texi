\input texinfo
@include version.texi
@settitle Reading and writing data with adftool @value{VERSION}
@syncodeindex pg cp
@setfilename adftool.info

@copying
Huh… I’ll have to think about copying conditions…
@end copying

@dircategory Texinfo documentation system
@direntry
* adftool: (adftool)Invoking adftool.
@end direntry

@titlepage
@title Reading and writing data with adftool
@subtitle for version @value{VERSION}, @value{UPDATED}
@author Vivien Kraus (@email{vivien.kraus@@univ-reims.fr})
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@node Top
@top Adftool

This is the user manual for adftool (version @value{VERSION},
@value{UPDATED}).

@menu
* The ADF file format::
* Invoking adftool::
* The libadftool API::
* Index::
@end menu

@node The ADF file format
@chapter The ADF file format

@cindex linked data
With the help of the World-wide Web, any dataset can be published in a
form that can be understood both by humans and by machines. The most
successful approach to that is @dfn{Linked Data}: each data point is
assigned a URI, and it is possible to follow the links from one piece
of data to another piece of data to build distributed knowledge
graphs, in a very similar manner that the web of documents lets user
click links to discover new pages. In that way, it is possible to
augment any dataset with new information, without touching at how
other systems use the same data.

@cindex RDF
@cindex subject
@cindex predicate
@cindex object
@cindex graph
@cindex triple
@cindex quad
@cindex statement
To do this, the Resource Description Framework (@dfn{RDF}) has been
introduced. It maps data to graphs. More specifically, a piece of data
consists of a @dfn{subject}, a @dfn{predicate}, and an
@dfn{object}. Each of them is a piece of data too. A later revision
added the notion of @dfn{graphs}, to partition the data into different
views. These four elements constitute a @dfn{quad}, or a @dfn{triple}
if the graph is the default graph. This is also called a
@dfn{statement}. So, good systems to store and query sets of quads or
triples need to be used to process linked data.

@cindex allotrope data format
@cindex ADF
@cindex hierarchical data format
@cindex HDF
This project is a more complete specification of the Allotrope Data
Format Quad Store, defined at
@url{https://docs.allotrope.org/ADF%20Quad%20Store%20API.html}. It is
designed to work within a Hierarchical Data Format file.

@menu
* Overview of the quad store::
* Building indices::
* The dictionary::
* Storage of statements::
* Indexing statements::
@end menu

@node Overview of the quad store
@section Overview of the quad store

The quad store is a data structure to hold triples or quads, along
with indices for efficient querying of the data set. The queries that
can be solved by the file format are of the form:

@example
?@var{subject} ?@var{predicate} ?@var{object} ?@var{graph} .
@end example

where @var{subject}, @var{predicate}, @var{object} and @var{graph} can
be defined as RDF nodes, or empty.

Internally, statements, or quads, are stored as a set of tuples. Each
element of the tuple may be a named node (IRI reference), a blank node
with an identifier, a typed literal, or a literal with an localization
mark.

@cindex named node
@cindex IRI reference
A named node is a resource that one can try to dereference to access
more data about the thing it represents. It is usually written between
angle brackets, as an IRI or IRI reference:

@example
<https://example.org/resource?query-arguments#identifier>
@end example

Subjects, predicates, objects or graphs can be named nodes.

@cindex blank node
A blank node is an unnamed resource that can be used to link other
resources together, scoped to the resource.

@example
<#me> <#knows> _:@var{someone} .
_:@var{someone} <#knows> <#someone-else> .
@end example

In this example, there is no more information about the person
identified as @var{someone}, than it is a link in my social
network. Any other resource using @code{_:@var{someone}} will be
interpreted as talking to someone else.

Only subjects and objects may be blank nodes.

@cindex literal
@cindex typed literal
@cindex type
@cindex langstring
@cindex langtag
The literal is a piece of data that does not have further metadata. It
is composed of a literal @dfn{value}, and an optional @dfn{type} or an
optional @dfn{langtag}. The type is identified by an IRI reference,
and it is usually expected to be one of the XML Schema Definition
vocabulary. If no type is present, the
@samp{<http://www.w3.org/2001/XMLSchema#string>} type is assumed. If the
string is to be presented to a human, then it may have a localization
tag, or langtag, indicating its locale.

@example
<#me> <#likes> "ananas"^^<http://www.w3.org/2001/XMLSchema#string> .
<#me> <#likes> "pineapples"@@en .
@end example

Literals can only be used as objects.

@cindex term ordering
@cindex order
We define an order on terms, as the byte lexicographic order of their
UTF-8 encoding (which is the same as the unicode code point
order). Each prefix of a term comes strictly before the term
itself. The textual representation of a term is constructed as:

@table @emph
@item for a named node
the IRI reference, without further percent-encoding, surrounded by
angle brackets (no whitespace);
@item for a blank node
the string @code{_:} (underscore, colon) followed by the unescaped
identifier of the blank node;
@item for a typed literal
a double quote, the escaped string (only the double quote character
and backslash character require escaping), another double quote, the
type marker @code{^^}, and the encoding of the type URI. If the type
is missing, @samp{<http://www.w3.org/2001/XMLSchema#string>} is
used. No extra whitespace is added;
@item for a langstring
a double quote, the escaped string, a double quote, the @code{@@}
character, and the langtag.
@end table

@cindex pattern
It is also possible to order statements, by using the lexicographic
order of the terms. We extend the notion of statement or quad to that
of @dfn{pattern}, by making the subject, predicate, object and graph
optional, and by stating that a missing object compares equal to any
term.

For query answering, the specification maintains 6 indices of the
data: @samp{GSPO}, @samp{GPOS}, @samp{GOSP}, @samp{SPOG}, @samp{POSG}
and @samp{OSPG}. In these acronyms, @samp{G} means graph, @samp{S}
means subject, @samp{P} means predicate and @samp{O} means object. Any
of the 16 search patterns that can be formed by specifying some of the
elements of the quad can be searched in one of these 6 indices. For
instance, if @var{predicate} and @var{graph} are set, the query can be
answered by using the @samp{GPOS} index.

The algorithm is, given a search @var{pattern}, to find in an index
all quads that compare equal to @var{pattern}, using the search order
that corresponds to the index.

@node Building indices
@section Building indices

@node The dictionary
@section The dictionary

@node Storage of statements
@section Storage of statements

@node Indexing statements
@section Indexing statements

@node Invoking adftool
@chapter Invoking adftool

@pindex adftool
@cindex invoking @command{adftool}

@node The libadftool API
@chapter The libadftool API

@cindex API (libadftool)
@cindex libadftool

@node Index
@unnumbered Index
@printindex cp

@bye
